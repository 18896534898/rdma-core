.TH IBV_GET_CQ_EVENT 3  "2006-10-31" "OpenIB" "OpenIB Programmer's Manual"

.SH "NAME"
ibv_get_cq_event, ibv_ack_cq_events \- get and acknowledge completion queue (CQ) events

.SH "SYNOPSIS"
.nf
.B #include <infiniband/verbs.h>
.sp
.BI "int ibv_get_cq_event(struct ibv_comp_channel " "*channel" ,
.BI "                     struct ibv_cq " "**cq" ", void " "**cq_context" );
.nl
.BI "void ibv_ack_cq_events(struct ibv_cq " "*cq" ", unsigned int " "nevents" );
.fi

.SH "DESCRIPTION"
.B ibv_get_cq_event()
get the next event from the completion event channel
.I channel\fR.
Fill the arguemnt
.I cq
with the CQ that got the event, and its context in
.I cq_context\fR.
.PP
.B ibv_ack_cq_events()
acknowledge
.I nevents
events on the CQ
.I cq\fR.

.SH "RETURN VALUE"
.B ibv_get_cq_event()
returns 0 on success, and \-1 on error.
.PP
.B ibv_ack_cq_events()
returns no value.
.SH "NOTES"
All completion events that
.B ibv_get_cq_event()
returns must be acknowledged using
.B ibv_ack_cq_events()\fR.
To avoid races, destroying a CQ will wait for all completion events to be acknowledged; this guarntees a one-to-one 
correspondence between acks and successful gets.

.SH "EXAMPLES"
The following code example demonstrates one possible way to work with completion events. It performs the following steps:
.PP
Stage I: Preparation
1. Creates a CQ
2. Requests for notification upon a new (first) completion event
.PP
Stage II: Completion Handling Routine
3. Wait for the completion event
4. Request for notification upon the next completion event
5. Empty the CQ
.PP
Note that an extra event may be triggered without having a corresponding completion entry in the CQ. This occurs if a completion entry is added to the CQ between Step 4 and Step 5, and is then emptied (polled).
.PP
.nf
cq = ibv_create_cq(ctx, 1, ev_ctx, channel, 0);
if (!cq) {
        fprintf(stderr, "Failed to create CQ\en");
        return 1;
}
.PP
/* Request notification before any completion can be created */
if (ibv_req_notify_cq(cq, 0)) {
        fprintf(stderr, "Couldn't request CQ notification\en");
        return 1;
}
.PP
\&.
\&.
\&.
.PP
/* Wait for the completion event */
if (ibv_get_cq_event(ctx->channel, &ev_cq, &ev_ctx)) {
        fprintf(stderr, "Failed to get cq_event\en");
        return 1;
}
.PP
/* Request notification upon the next completion event */
if (ibv_req_notify_cq(ctx->cq, 0)) {
        fprintf(stderr, "Couldn't request CQ notification\en");
        return 1;
}
.PP
/* Empty the CQ: poll all of the completions from the CQ (if any exist) */
do {
        ne = ibv_poll_cq(cq, 1, &wc);
        if (ne < 0) {
                fprintf(stderr, "Failed to poll completions from the CQ\en");
                return 1;
        }
.PP
        if (wc.status != IBV_WC_SUCCESS) {
                fprintf(stderr, "Completion with status 0x%x was found\en", wc.status);
                return 1;
        }
} while (ne);
.fi

.SH "CONFORMING TO"
InfiniBand Architecture Specification, Release 1.2.

.SH "SEE ALSO"
.BR ibv_create_comp_channel (3),
.BR ibv_create_cq (3),
.BR ibv_req_notify_cq (3),
.BR ibv_poll_cq (3)

.SH "AUTHORS"
.TP
Dotan Barak
.RI < dotanb@mellanox.co.il >
